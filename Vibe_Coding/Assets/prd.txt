# 🎮 Duskfall: 2인 생존 디펜스 시뮬레이터 PRD

<context>
# Overview
Duskfall은 Unity(URP) 기반의 2인 협동 생존 디펜스 게임입니다. 낮에는 자원을 채집하고 방어 구조물을 건설하며, 밤에는 몰려오는 좀비로부터 기지를 지켜내야 합니다. 이 프로젝트의 핵심 목표는 GPU Instancing, Job System 등 최신 게임 개발 기술을 적극적으로 실험하고, 적용 전후의 성능을 구체적인 데이터로 비교 분석하여 기술 중심의 포트폴리오를 제작하는 것입니다.

# Core Features
- **2인 협동 플레이**: Unity Netcode for GameObjects와 Relay를 사용하여 2명의 플레이어가 실시간으로 협동합니다. 플레이어의 행동, 자원, 설치된 구조물, 적의 상태가 모두 동기화됩니다.
- **생존 및 건설**: 낮 동안 맵 곳곳에서 자원을 채집하고, 이를 사용해 방어 타워, 벽 등 다양한 전략적 구조물을 건설합니다. 모든 자원과 구조물은 두 플레이어가 공유합니다.
- **웨이브 디펜스**: 밤이 되면 좀비들이 기지를 향해 몰려옵니다. 플레이어들은 직접 전투를 벌이거나, 낮에 건설한 방어 구조물을 활용해 좀비 웨이브를 막아내야 합니다.
- **기술 실험 및 최적화**: 렌더링(GPU Instancing, LOD), 멀티스레딩(Job System), 데이터(Binary 저장) 등 다양한 분야의 최적화 기술을 적용하고, 토글 기능을 통해 즉각적으로 성능 변화를 비교/분석합니다.

# User Experience
- **역할 분담 플레이**: 한 명은 자원 수집에 집중하고 다른 한 명은 기지 건설을 담당하는 등, 플레이어 간의 자연스러운 역할 분담과 협동을 유도합니다.
- **직관적 디버그 및 실험 환경**: 개발 중 성능 변화를 쉽게 체감하고 분석할 수 있도록 각종 최적화 기술의 On/Off 토글, 실시간 성능 지표(FPS, DrawCall 등) UI, AI 상태 시각화 등 강력한 디버그 도구를 제공합니다.
- **빠른 테스트 지원**: 낮/밤 즉시 전환, 자원 무제한 모드 등 반복적인 테스트를 효율적으로 진행할 수 있는 기능을 지원합니다.
</context>
<PRD>
# Technical Architecture
- **엔진**: Unity (Universal Render Pipeline)
- **네트워크**: Unity Netcode for GameObjects, Unity Relay. 클라이언트가 입력을 보내면 서버가 검증 후 상태를 결정하는 'Input-based Synchronization' 모델을 채택하여 Transform 직접 동기화를 최소화합니다.
- **렌더링**: 다수의 동일한 적(좀비) 렌더링 시 GPU Instancing을 적용합니다. 시야에서 벗어난 오브젝트는 Occlusion Culling과 LOD(Level of Detail) 그룹으로 렌더링 부하를 줄입니다.
- **AI**: 수백 마리의 좀비 AI 경로 탐색 및 행동 로직은 Unity Job System과 Burst Compiler를 사용하여 병렬 처리합니다.
- **데이터 저장**: 초기 개발 단계에서는 JSON을 사용하여 가독성과 디버깅 편의성을 확보하고, 출시 버전에서는 파일 크기와 속도 최적화를 위해 Binary 직렬화 및 압축을 적용합니다.

# Development Roadmap
- **MVP 요구사항**:
  1.  싱글 플레이어 기반의 캐릭터 조작 및 자원 수집/건설 기능 구현.
  2.  낮/밤 사이클 구현.
  3.  기본적인 좀비 AI 및 웨이브 스폰 시스템 구현.
  4.  2인 협동 플레이를 위한 기본 네트워크 동기화(플레이어 위치, 구조물) 구현.
  5.  핵심 최적화 기술(Instancing, Job System) 적용 및 성능 비교 토글 기능 구현.
- **Future Enhancements**:
  1.  다양한 종류의 적과 방어 구조물 추가.
  2.  플레이어 스킬 및 장비 시스템 도입.
  3.  세이브/로드 시스템 고도화 (마이그레이션 기능 포함).
  4.  그래픽 및 사운드 이펙트 폴리싱.

# Logical Dependency Chain
1.  **기본 플레이 환경 구축**: 캐릭터 이동, 카메라, 기본 환경 애셋 배치.
2.  **핵심 게임 로직 구현**: 자원 채집 -> 인벤토리 -> 구조물 건설 시스템.
3.  **적(AI) 시스템 구현**: 단일 스레드 기반의 기본 좀비 AI 구현.
4.  **네트워크 연동**: 2인 플레이어의 위치 및 기본 상호작용 동기화.
5.  **Job System 전환**: 기본 좀비 AI를 Job System 기반으로 전환하고 성능 비교.
6.  **GPU Instancing 적용**: 좀비 렌더링에 Instancing을 적용하고 Draw Call 변화 비교.
7.  **데이터 저장 구현**: JSON 기반으로 게임 상태 저장/로드 구현.
8.  **시스템 고도화**: Binary 저장 전환, LOD 적용, 디버그 툴 제작 등.

# Risks and Mitigations
- **기술적 난이도**: Job System, Netcode 등 복잡한 기술 구현 시 예상보다 많은 시간이 소요될 수 있음. -> **Mitigation**: 각 기술별로 작은 프로토타입을 먼저 제작하여 기술을 검증하고, 구현 범위를 명확히 한정합니다.
- **성능 목표 미달**: 500마리 AI 구동 시 60fps 유지 목표에 실패할 가능성. -> **Mitigation**: 프로파일러를 통해 병목 구간을 지속적으로 분석하고, AI 로직의 복잡도를 조절하거나 추가 최적화 기법을 도입합니다.
- **네트워크 비동기화**: 복잡한 상호작용에서 상태 불일치 문제가 발생할 수 있음. -> **Mitigation**: 모든 게임 로직을 서버(Host) 측에서 검증하고 결과를 클라이언트에 전달하는 구조를 철저히 지키고, 주요 동기화 변수에 대한 로그를 철저히 관리합니다.

# Appendix
- **포트폴리오 구성 계획**:
  - **기술 리포트**: 각 기술의 원리, Unity에서의 적용 방식, 장단점을 상세히 문서화.
  - **비교 실험 자료**: 최적화 기술 적용 전/후의 FPS, CPU 점유율, Draw Call, 메모리 사용량 등 구체적인 수치를 그래프와 스크린샷으로 정리.
  - **회고**: 구현 과정에서 겪었던 문제점과 해결 과정을 기록하여 문제 해결 능력을 어필.
- **데이터 마이그레이션 예시**:
  - `v1.0` -> `v1.1`: `PlayerSaveData`에 `stamina` 필드 추가 시, v1.0 세이브 파일 로드 시 `stamina`에 기본값(100)을 할당하는 마이그레이션 로직 추가.
  - `v1.1` -> `v1.2`: `Inventory`가 아이템 ID 리스트에서 `(ID, 개수)` 딕셔너리 구조로 변경될 경우, 기존 리스트를 순회하며 새로운 딕셔너리 구조로 변환하는 마이그레이션 함수 작성. 