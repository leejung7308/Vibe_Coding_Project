# Unity 프로젝트 개발 규칙 (.cursorrules)

1. 성능이 중요한 Unity 코드 작성 시 ECS 친화적 패턴을 따릅니다. (예: 깊은 MonoBehaviour 계층 대신 struct, ScriptableObject 등 데이터 기반 설계 선호)
2. 게임플레이 시스템 구현 시 로직과 비주얼을 분리합니다. (예: 타워 발사, AI 행동 등은 순수 로직 클래스로, MonoBehaviour는 렌더링 계층에서만 연결)
3. 네트워크 동기화 코드 작성 시 클라이언트는 입력만 전송하고, 서버가 검증 및 상태 브로드캐스트를 담당합니다. 예측 가능한 동기화를 위해 ServerRpc + NetworkVariable 조합을 권장합니다.
4. 새로운 GameObject를 씬에 추가할 때 렌더링 부하가 크면 GPU Instancing 또는 LODGroup 지원 여부를 확인합니다. 성능 비교를 위해 프로파일러 마커를 추가합니다.
5. 데이터 저장 시 version 필드를 반드시 포함하고, 구조가 변경되면 마이그레이션 함수를 작성합니다. 로드 시 누락된 필드는 기본값을 사용합니다.
6. AI 행동 테스트 시 Gizmo 그리기를 활성화하고 상태 전이 로그를 남깁니다. 성능 테스트를 위해 시각적 디버깅을 끌 수 있는 토글을 포함합니다.
7. 최적화 코드를 커밋할 때 비교 테스트를 위해 비최적화 버전으로 되돌릴 수 있는 토글(불리언 플래그 또는 스크립트 정의 심볼)을 반드시 둡니다.
8. Jobified 시스템을 다룰 때 성능 테스트가 가능한 모듈로 감쌉니다. JobHandle.Complete()를 명시적으로 호출하고, NativeArray 누수에 주의합니다.
9. 디버그 UI 툴 작성 시 에디터 전용 또는 개발자 핫키로만 접근 가능하게 하며, 릴리즈 빌드에는 포함하지 않습니다.
10. 파일명 및 클래스명에는 역할 또는 컨텍스트 접미사(예: TowerDefenseSystem, SaveDataMigrator, ZombieAIJob 등)를 포함해 대규모 코드베이스에서 가독성을 높입니다. 

# Duskfall 프로젝트 특화 추가 규칙

11. 모든 최적화/신기술(Instancing, LOD, Job System 등)은 On/Off 토글이 가능하도록 구현하여 실험 및 비교가 용이해야 합니다.
12. 네트워크 동기화는 반드시 입력 기반으로 설계하며, Transform 등 직접 동기화는 최소화합니다. 서버는 모든 상태를 검증 및 결정합니다.
13. 실험/디버그용 UI, 기능(성능 측정, AI 상태, 세이브 뷰어 등)은 개발/에디터 전용으로 구현하고, 릴리즈 빌드에는 포함하지 않습니다.
14. 저장 데이터 구조에는 항상 version 필드를 포함하고, 구조 변경 시 버전 기반 마이그레이션 함수를 제공합니다. 불일치 시 경고 또는 초기화 옵션을 제공합니다.
15. 실험 결과(성능, 트래픽, 파일 크기 등)는 수치와 스크린샷 등으로 기록하여 포트폴리오에 활용할 수 있도록 합니다.
16. AI, 렌더링, 저장 등 주요 시스템은 2인 협동 플레이 환경(네트워크)에서의 동작을 반드시 검증합니다.
17. 실험/비교 목적의 기능은 빠른 테스트(낮/밤 전환, 자원 무제한 등) 모드를 지원해야 하며, 이 역시 개발/에디터 전용으로 구현합니다. 